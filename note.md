BigO 与复杂度
时间复杂度：用来表示随着输入的增加，函数运行时间的增长趋势的一种表示方法
比如：
线性时间 O(n)
常数时间 O(1)
次方时间 O(n^2)

计算时间复杂度方法：
1.find the fastest growing term
2.take out the coefficient

ex:
T = an + b = O(n)
T = cn^2 +dn + e = O(n^2)


空间复杂度：用来表示随着输入的增加，函数空间存储的增长趋势的一种表示方法

数组
1.数组可以用双指针解决一些问题
2.数组可以从头到尾，或者从尾到头
3.数组问题可以猜想是否排序后有助于解决问题

链表
1.链表一般用nil值结束for循环
2.两个链表追赶可以通过快慢指针，或者速度一样，路程差追赶
3.判断链表是否相等 直接用等号 在正式的编译环境是行不通的 需要用reflect.DeepEqual 或者自己写个equal方法
4.递归解决链表问题 往往比较简单，可先考虑是否能用递归做
5.链表为引用类型，修改时一定要考虑值是否变动
6.链表的Next 要一定判断是否为空
7.单向链表，节点后面的引用 改变，是不会影响之前节点的
8.快慢指针的起点选择，快指针是否要快一步，结合题目判断是否快一步区分一些属性

树
定义：
二叉树：
1.是有序树
2.各节点的度不能超过2

满二叉树：
1.除根节点，其余每一个节点的度为2
特性：深度为k，节点数为2^k-1 叶子节点数为2^(k-1)

完全二叉树：
从上到下，从左到右都是满的
特性:
父节点为i/2
if 2i>n 则 i节点无左孩 否则左孩为2i
if 2i+1>n 则i节点无右孩 否则右孩为2i+1

完美二叉树 = 满二叉树 + 完全二叉树 + 叶子节点拉满

平衡树(Balance Tree，BT) 指的是，任意节点的子树的高度差都小于等于1。常见的符合平衡树的有，B树（多路平衡搜索树）、AVL树（二叉平衡搜索树）等。

前序遍历：根左右 dfs
中序遍历：左根右 dfs 先到最左的叶子节点，也为该范围的root
后序遍历：左右根 dfs 前序的反插
层次遍历：bfs 用队列

前中后遍历可以通过节点颜色标记，第一次入栈是不能访问其值的，因为第一次入栈是第一次访问该节点，需要先访问该节点的左子树，这时会把该结点和左子树都入栈，所以第二次出栈就可以访问该结点的值啦

总结：
tree的题一般都用递归思路去解

最大堆：
建堆：一般从倒数第二层开始，从下向上开始堆化，每次堆化是把小的值放到子孩层
取值：从堆顶拿值，不能直接拿，不然堆没有顶，破坏原先数据结构，与末位置替换，拿出，末位值到堆顶之后做一次乡下的堆化
插值：插入末位，从下向上，然后对其做向上的堆化，把最大值放入父层，直到不需要放为止

